# Copyright (c) 2022 Graphcore Ltd. All rights reserved.

# THIS FILE IS AUTOGENERATED. Rerun SST after editing source file: walkthrough.py

import os
import subprocess

os.environ["PVTI_OPTIONS"] = '{"enable":"true"}'
subprocess.run(["sh", "./get_data.sh"])
subprocess.run(["python3", "popart_mnist.py"])

# Grab the most recently modified PVTI file
from pathlib import Path

working_dir = Path(".").glob("./*.pvti")
pvti_files = [f for f in working_dir if f.is_file()]
pvti_files.sort(reverse=True, key=lambda a: a.stat().st_mtime)
trace_path = str(pvti_files[0])

# Open the file
import pva

trace = pva.openTrace(trace_path)

print("Number of processes: ", len(trace.processes))

process = trace.processes[0]
print("Number of threads on process ", process.pid, ": ", len(process.threads))

thread = process.threads[0]
print("Number of events on thread ", thread.tid, ": ", len(thread.events))

event = thread.events[0]
print("Event '", event.label, "' lasted ", event.duration, " microseconds")
print("The event has ", len(event.children()), " children")


class EpochStats:
    longest = None
    shortest = None
    average = 0
    count = 0


from typing import List


def traverse_events(events: List[pva.Event], stats: EpochStats):
    for event in events:
        # Record info about Epoch events
        if event.label.startswith("Epoch"):
            # Increase our count, and iteratively calculate the mean duration
            stats.count += 1
            stats.average += (event.duration - stats.average) / stats.count

            # Fill our slot for the longest event if the current event is
            # longer, or we just don't have one yet
            if stats.longest is None or event.duration > stats.longest.duration:
                stats.longest = event

            # Fill our slot for the shortest event if the current event is
            # shorter, or we just don't have one yet
            if stats.shortest is None or event.duration < stats.shortest.duration:
                stats.shortest = event

        # Traverse children too
        traverse_events(event.children(), stats)


trace = pva.openTrace(trace_path)
stats = EpochStats()

for process in trace.processes:
    for thread in process.threads:
        traverse_events(thread.events, stats)

print(f"The longest epoch '{stats.longest.label}' lasted {stats.longest.duration} microseconds.")
print(f"The shortest epoch '{stats.shortest.label}' lasted {stats.shortest.duration} microseconds.")
print(f"Epochs took {stats.average:.0f} microseconds on average, out of {stats.count} epochs in total.")

# Generated:2022-09-08T11:14 Source:walkthrough.py SST:0.0.8
